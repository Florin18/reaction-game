<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark" />
    <title>Reaction Timer — Portfolio Grade</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@600;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --bg: #0f172a;
        --surface: #1e293b;
        --accent: #22c55e; /* ready */
        --error: #ef4444; /* too_early */
        --text: #f8fafc;
        --muted: #94a3b8;

        --radius: 16px;
        --radius-sm: 12px;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        --shadow-soft: 0 10px 20px rgba(0, 0, 0, 0.25);

        --ring: 0 0 0 3px rgba(34, 197, 94, 0.35);
        --ring-error: 0 0 0 3px rgba(239, 68, 68, 0.35);

        --t-fast: 150ms;
        --t: 180ms;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        color: var(--text);
        background: radial-gradient(1200px 900px at 20% 10%, rgba(34, 197, 94, 0.08), transparent 60%),
          radial-gradient(900px 700px at 80% 30%, rgba(59, 130, 246, 0.08), transparent 60%),
          radial-gradient(900px 700px at 50% 90%, rgba(236, 72, 153, 0.06), transparent 60%),
          var(--bg);
        overflow-x: hidden;
      }

      .ui {
        position: relative;
        z-index: 1;
        min-height: 100%;
        display: grid;
        place-items: center;
        padding: 20px;
      }

      .wrap {
        width: 100%;
        max-width: 980px;
        display: grid;
        gap: 16px;
      }

      .header {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 16px;
        padding: 4px 2px;
      }

      .brand {
        display: grid;
        gap: 6px;
      }

      .brand h1 {
        margin: 0;
        font-family: "Space Grotesk", Inter, system-ui, sans-serif;
        font-size: clamp(22px, 2.2vw, 30px);
        letter-spacing: -0.02em;
        line-height: 1.1;
      }

      /* removed subtitle paragraph */

      .hint {
        display: none;
        color: var(--muted);
        font-size: 13px;
        text-align: right;
      }

      @media (min-width: 720px) {
        .hint {
          display: block;
        }
      }

      .card {
        background: rgba(30, 41, 59, 0.78);
        border: 1px solid rgba(148, 163, 184, 0.14);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        overflow: hidden;
      }

      .grid {
        display: grid;
        gap: 16px;
      }

      @media (min-width: 960px) {
        .grid {
          grid-template-columns: 1.25fr 0.75fr;
          align-items: start;
        }
      }

      .game {
        padding: 18px;
        display: grid;
        gap: 14px;
      }

      .arena {
        position: relative;
        border-radius: calc(var(--radius) - 4px);
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.14);
        background: linear-gradient(180deg, rgba(15, 23, 42, 0.6), rgba(15, 23, 42, 0.35));
        box-shadow: var(--shadow-soft);
        isolation: isolate; /* keep layers clean */
      }

      /* Three.js canvas INSIDE the arena */
      .arenaCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
        z-index: 0;
        opacity: 0.98;
      }

      /* subtle dark veil so text stays readable over 3D */
      .arenaCanvasVeil {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 1;
        background: radial-gradient(900px 320px at 50% 10%, rgba(0, 0, 0, 0.22), transparent 60%),
          linear-gradient(180deg, rgba(0, 0, 0, 0.18), rgba(0, 0, 0, 0.08));
        opacity: 0.9;
      }

      /* State tint overlay (clear UX feedback, independent from 3D) */
      .arena::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0;
        transition: opacity var(--t) ease;
        z-index: 2; /* above canvas + veil, below button content */
      }
      .arena[data-state="waiting"]::before {
        opacity: 0.18;
        background: radial-gradient(900px 320px at 50% 20%, rgba(239, 68, 68, 0.55), transparent 60%),
          linear-gradient(180deg, rgba(239, 68, 68, 0.14), transparent);
      }
      .arena[data-state="ready"]::before {
        opacity: 0.16;
        background: radial-gradient(900px 320px at 50% 20%, rgba(34, 197, 94, 0.55), transparent 60%),
          linear-gradient(180deg, rgba(34, 197, 94, 0.12), transparent);
      }
      .arena[data-state="too_early"]::before {
        opacity: 0.24;
        background: radial-gradient(900px 320px at 50% 20%, rgba(239, 68, 68, 0.7), transparent 60%),
          linear-gradient(180deg, rgba(239, 68, 68, 0.18), transparent);
      }

      .arenaButton {
        appearance: none;
        border: none;
        width: 100%;
        min-height: 220px;
        padding: 18px;
        border-radius: calc(var(--radius) - 4px);
        color: var(--text);
        background: transparent;
        cursor: pointer;
        display: grid;
        place-items: center;
        text-align: center;
        transition: transform var(--t) ease, box-shadow var(--t) ease;
        outline: none;
        position: relative;
        z-index: 3; /* above overlays */
      }

      @media (min-width: 720px) {
        .arenaButton {
          min-height: 260px;
        }
      }

      .arenaButton:focus-visible {
        box-shadow: var(--ring);
      }
      .arenaButton[data-state="waiting"]:focus-visible,
      .arenaButton[data-state="too_early"]:focus-visible {
        box-shadow: var(--ring-error);
      }

      .arenaButton:active {
        transform: scale(0.995);
      }

      .statePillRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 999px;
        font-size: 13px;
        color: var(--muted);
        border: 1px solid rgba(148, 163, 184, 0.14);
        background: rgba(15, 23, 42, 0.35);
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.65);
        box-shadow: 0 0 0 3px rgba(148, 163, 184, 0.12);
      }

      .pill[data-variant="ready"] .dot {
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.16);
      }

      .pill[data-variant="error"] .dot {
        background: var(--error);
        box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.16);
      }

      .pill strong {
        color: var(--text);
        font-weight: 600;
      }

      .actions {
        display: inline-flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        appearance: none;
        border: 1px solid rgba(148, 163, 184, 0.16);
        background: rgba(15, 23, 42, 0.35);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        font-size: 13px;
        cursor: pointer;
        transition: transform var(--t-fast) ease, background var(--t-fast) ease, border-color var(--t-fast) ease;
        outline: none;
      }

      .btn:hover {
        transform: translateY(-1px);
        border-color: rgba(148, 163, 184, 0.24);
        background: rgba(15, 23, 42, 0.5);
      }

      .btn:focus-visible {
        box-shadow: var(--ring);
      }

      .btn.danger:focus-visible {
        box-shadow: var(--ring-error);
      }

      .btn.danger:hover {
        border-color: rgba(239, 68, 68, 0.35);
      }

      .arenaInner {
        display: grid;
        gap: 12px;
        max-width: 620px;
      }

      .headline {
        font-family: "Space Grotesk", Inter, system-ui, sans-serif;
        margin: 0;
        font-size: clamp(18px, 2.2vw, 22px);
        letter-spacing: -0.01em;
      }

      .sub {
        margin: 0;
        color: var(--muted);
        font-size: 14px;
        line-height: 1.5;
      }

      .big {
        margin: 0;
        font-family: "Space Grotesk", Inter, system-ui, sans-serif;
        font-weight: 700;
        letter-spacing: -0.03em;
        font-size: clamp(56px, 7vw, 80px);
        line-height: 1.02;
      }

      .big[data-tone="accent"] {
        color: var(--accent);
        text-shadow: 0 0 18px rgba(34, 197, 94, 0.22);
      }

      .big[data-tone="error"] {
        color: var(--error);
        text-shadow: 0 0 18px rgba(239, 68, 68, 0.22);
      }

      .metaRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      @media (min-width: 720px) {
        .metaRow {
          grid-template-columns: 1fr 1fr;
        }
      }

      .statCard {
        padding: 14px;
        border-radius: var(--radius-sm);
        border: 1px solid rgba(148, 163, 184, 0.14);
        background: rgba(15, 23, 42, 0.35);
        display: grid;
        gap: 6px;
        min-height: 78px;
      }

      .statCard .k {
        color: var(--muted);
        font-size: 12px;
        letter-spacing: 0.02em;
        text-transform: uppercase;
      }

      .statCard .v {
        font-family: "Space Grotesk", Inter, system-ui, sans-serif;
        font-size: 22px;
        font-weight: 700;
        letter-spacing: -0.02em;
      }

      .sidebar {
        padding: 18px;
        display: grid;
        gap: 14px;
      }

      .sidebar h2 {
        margin: 0;
        font-family: "Space Grotesk", Inter, system-ui, sans-serif;
        font-size: 18px;
        letter-spacing: -0.01em;
      }

      .list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: grid;
        gap: 8px;
      }

      .list li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.14);
        background: rgba(15, 23, 42, 0.35);
      }

      .list .label {
        color: var(--muted);
        font-size: 13px;
      }

      .list .value {
        font-family: "Space Grotesk", Inter, system-ui, sans-serif;
        font-size: 16px;
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      .attempts {
        display: grid;
        gap: 8px;
      }

      .attemptsHeader {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
        flex-wrap: wrap;
      }

      .attemptsHeader .muted {
        color: var(--muted);
        font-size: 12px;
      }

      .attemptsGrid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
      }

      .chip {
        padding: 10px 8px;
        border-radius: 12px;
        text-align: center;
        border: 1px solid rgba(148, 163, 184, 0.14);
        background: rgba(15, 23, 42, 0.35);
        font-family: "Space Grotesk", Inter, system-ui, sans-serif;
        font-weight: 700;
        letter-spacing: -0.01em;
        font-size: 14px;
        min-height: 40px;
        display: grid;
        place-items: center;
      }

      .chip.empty {
        color: rgba(148, 163, 184, 0.55);
        font-weight: 600;
        font-family: Inter, system-ui, sans-serif;
      }

      .arena[data-state="waiting"] {
        box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.22), 0 14px 34px rgba(0, 0, 0, 0.35);
      }

      .arena[data-state="ready"] {
        box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.28), 0 18px 40px rgba(0, 0, 0, 0.45);
      }

      .arena[data-state="too_early"] {
        box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.28), 0 18px 40px rgba(0, 0, 0, 0.45);
        animation: shake 260ms ease-in-out 0ms 1;
      }

      @keyframes shake {
        0% {
          transform: translateX(0);
        }
        20% {
          transform: translateX(-6px);
        }
        40% {
          transform: translateX(6px);
        }
        60% {
          transform: translateX(-4px);
        }
        80% {
          transform: translateX(4px);
        }
        100% {
          transform: translateX(0);
        }
      }

      .sr-only {
        position: absolute !important;
        width: 1px !important;
        height: 1px !important;
        padding: 0 !important;
        margin: -1px !important;
        overflow: hidden !important;
        clip: rect(0, 0, 0, 0) !important;
        white-space: nowrap !important;
        border: 0 !important;
      }
    </style>
  </head>

  <body>
    <div class="ui">
      <div class="wrap">
        <header class="header">
          <div class="brand">
            <h1>Reaction Timer</h1>
          </div>
          <div class="hint">Keyboard: <strong>Space</strong> / <strong>Enter</strong></div>
        </header>

        <section class="card grid" aria-label="Reaction Timer Game">
          <div class="game">
            <div class="statePillRow">
              <div class="pill" id="statePill" data-variant="neutral">
                <span class="dot" aria-hidden="true"></span>
                <span>State: <strong id="stateLabel">idle</strong></span>
              </div>

              <div class="actions">
                <button class="btn" id="btnResetSession" type="button" title="Reset session stats">Reset session</button>
                <button class="btn danger" id="btnClearBest" type="button" title="Clear best time from storage">Clear best</button>
              </div>
            </div>

            <div class="arena" id="arena" data-state="idle">
              <!-- 3D shape is now INSIDE the clickable box -->
              <canvas class="arenaCanvas" id="arena3d" aria-hidden="true"></canvas>
              <div class="arenaCanvasVeil" aria-hidden="true"></div>

              <button
                class="arenaButton"
                id="arenaButton"
                type="button"
                data-state="idle"
                aria-describedby="helpText"
              >
                <div class="arenaInner">
                  <h2 class="headline" id="headline">Click to start</h2>
                  <p class="sub" id="helpText">When you start, wait for green. Click (or press Space/Enter) as fast as you can.</p>
                  <p class="big" id="big" aria-label="Reaction time readout">—</p>
                </div>
              </button>
            </div>

            <div class="metaRow" aria-label="Summary statistics">
              <div class="statCard">
                <div class="k">Best (persisted)</div>
                <div class="v" id="bestValue">—</div>
              </div>
              <div class="statCard">
                <div class="k">Average (session)</div>
                <div class="v" id="avgValue">—</div>
              </div>
            </div>

            <div class="sr-only" aria-live="polite" aria-atomic="true" id="live"></div>
          </div>

          <aside class="sidebar" aria-label="Attempts and details">
            <h2>Attempts</h2>

            <div class="attempts">
              <div class="attemptsHeader">
                <div class="muted">Last 10 (most recent first)</div>
                <div class="muted" id="sessionCount">Session: 0</div>
              </div>

              <div class="attemptsGrid" id="attemptsGrid" aria-label="Last 10 attempts grid"></div>
            </div>

            <ul class="list" aria-label="Current result details">
              <li>
                <span class="label">Current</span>
                <span class="value" id="currentValue">—</span>
              </li>
              <li>
                <span class="label">Last</span>
                <span class="value" id="lastValue">—</span>
              </li>
            </ul>
          </aside>
        </section>
      </div>
    </div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <script>
      (() => {
        "use strict";

        const STATES = Object.freeze({
          IDLE: "idle",
          WAITING: "waiting",
          READY: "ready",
          TOO_EARLY: "too_early",
          RESULT: "result",
        });

        const STORAGE_KEY_BEST = "rtg_best_ms_v1";

        const clampInt = (n, min, max) => Math.max(min, Math.min(max, n | 0));
        const now = () => performance.now();

        const formatMs = (ms) => {
          if (!Number.isFinite(ms)) return "—";
          return `${Math.round(Math.max(0, ms))} ms`;
        };

        const avg = (arr) => {
          if (!arr.length) return NaN;
          let s = 0;
          for (let i = 0; i < arr.length; i++) s += arr[i];
          return s / arr.length;
        };

        const Storage = (() => {
          const readBest = () => {
            try {
              const raw = localStorage.getItem(STORAGE_KEY_BEST);
              if (!raw) return NaN;
              const n = Number(raw);
              return Number.isFinite(n) && n > 0 ? n : NaN;
            } catch {
              return NaN;
            }
          };

          const writeBest = (ms) => {
            try {
              if (Number.isFinite(ms) && ms > 0) localStorage.setItem(STORAGE_KEY_BEST, String(Math.round(ms)));
            } catch {}
          };

          const clearBest = () => {
            try {
              localStorage.removeItem(STORAGE_KEY_BEST);
            } catch {}
          };

          return Object.freeze({ readBest, writeBest, clearBest });
        })();

        const Stats = (() => {
          let attempts = [];
          const addAttempt = (ms) => {
            if (!Number.isFinite(ms) || ms <= 0) return;
            attempts.unshift(ms);
            if (attempts.length > 10) attempts = attempts.slice(0, 10);
          };
          const resetSession = () => {
            attempts = [];
          };
          const getAttempts = () => attempts.slice();
          const getAverage = () => avg(attempts);
          const getLast = () => (attempts.length ? attempts[0] : NaN);
          const getCount = () => attempts.length;

          return Object.freeze({ addAttempt, resetSession, getAttempts, getAverage, getLast, getCount });
        })();

        const UI = (() => {
          const el = {
            arena: document.getElementById("arena"),
            arenaButton: document.getElementById("arenaButton"),
            headline: document.getElementById("headline"),
            helpText: document.getElementById("helpText"),
            big: document.getElementById("big"),
            stateLabel: document.getElementById("stateLabel"),
            statePill: document.getElementById("statePill"),
            bestValue: document.getElementById("bestValue"),
            avgValue: document.getElementById("avgValue"),
            currentValue: document.getElementById("currentValue"),
            lastValue: document.getElementById("lastValue"),
            attemptsGrid: document.getElementById("attemptsGrid"),
            sessionCount: document.getElementById("sessionCount"),
            live: document.getElementById("live"),
            btnResetSession: document.getElementById("btnResetSession"),
            btnClearBest: document.getElementById("btnClearBest"),
          };

          const announce = (msg) => {
            el.live.textContent = "";
            requestAnimationFrame(() => {
              el.live.textContent = msg;
            });
          };

          const setStatePill = (state) => {
            el.stateLabel.textContent = state;
            let variant = "neutral";
            if (state === STATES.READY) variant = "ready";
            if (state === STATES.WAITING || state === STATES.TOO_EARLY) variant = "error";
            el.statePill.dataset.variant = variant;
          };

          const setArenaState = (state) => {
            el.arena.dataset.state = state;
            el.arenaButton.dataset.state = state;
          };

          const setPrimaryReadout = (text, tone) => {
            el.big.textContent = text;
            if (tone === "accent") el.big.dataset.tone = "accent";
            else if (tone === "error") el.big.dataset.tone = "error";
            else el.big.removeAttribute("data-tone");
          };

          const renderAttempts = (attempts) => {
            el.attemptsGrid.innerHTML = "";
            for (let i = 0; i < 10; i++) {
              const chip = document.createElement("div");
              chip.className = "chip";
              if (i >= attempts.length) {
                chip.classList.add("empty");
                chip.textContent = "—";
              } else {
                chip.textContent = `${Math.round(attempts[i])}`;
                chip.setAttribute("aria-label", `Attempt ${i + 1}: ${formatMs(attempts[i])}`);
              }
              el.attemptsGrid.appendChild(chip);
            }
          };

          const renderStats = ({ currentMs, bestMs, avgMs, lastMs, sessionCount }) => {
            el.bestValue.textContent = formatMs(bestMs);
            el.avgValue.textContent = formatMs(avgMs);
            el.currentValue.textContent = formatMs(currentMs);
            el.lastValue.textContent = formatMs(lastMs);
            el.sessionCount.textContent = `Session: ${sessionCount}`;
          };

          const renderStateView = (state, data = {}) => {
            setStatePill(state);
            setArenaState(state);

            let headline = "Click to start";
            let help = "When you start, wait for green. Click (or press Space/Enter) as fast as you can.";
            let bigText = "—";
            let tone = null;

            if (state === STATES.IDLE) {
              headline = "Click to start";
              help = "You will get a random delay. React when the panel turns green.";
              bigText = "—";
              tone = null;
            } else if (state === STATES.WAITING) {
              headline = "WAIT";
              help = "Red means do not click yet. Wait for green.";
              bigText = "HOLD";
              tone = "error";
              announce("Wait. Do not click yet.");
            } else if (state === STATES.READY) {
              headline = "GO!";
              help = "Click now!";
              bigText = "NOW";
              tone = "accent";
              announce("Go!");
            } else if (state === STATES.TOO_EARLY) {
              headline = "False start";
              help = "You clicked too early. Click to try again.";
              bigText = "Too early";
              tone = "error";
              announce("False start. You clicked too early.");
            } else if (state === STATES.RESULT) {
              headline = "Reaction time";
              help = "Click to play again.";
              bigText = formatMs(data.currentMs);
              tone = "accent";
              if (Number.isFinite(data.currentMs)) announce(`Reaction time ${Math.round(data.currentMs)} milliseconds.`);
            }

            el.headline.textContent = headline;
            el.helpText.textContent = help;
            setPrimaryReadout(bigText, tone);
          };

          return Object.freeze({ el, renderStateView, renderAttempts, renderStats, announce });
        })();

        const Visuals3D = (() => {
          const canvas = document.getElementById("arena3d");
          const arena = document.getElementById("arena");

          let renderer = null;
          let scene = null;
          let camera = null;

          let group = null;
          let knot = null;
          let core = null;
          let satellites = [];
          let lightAccent = null;

          let rafId = 0;

          const anim = {
            targetSpeed: 0.18,
            speed: 0.18,
            targetGlow: 0.1,
            glow: 0.1,
            targetRed: 0.0,
            red: 0.0,
            targetJitter: 0.0,
            jitter: 0.0,
          };

          const COLORS = {
            surface: 0x1e293b,
            muted: 0x94a3b8,
            accent: 0x22c55e,
            error: 0xef4444,
          };

          const prefersReducedMotion = () =>
            window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

          const lerp = (a, b, t) => a + (b - a) * t;

          const getArenaSize = () => {
            const r = arena.getBoundingClientRect();
            return { w: Math.max(1, Math.round(r.width)), h: Math.max(1, Math.round(r.height)) };
          };

          const init = () => {
            if (!window.THREE) return;

            renderer = new THREE.WebGLRenderer({
              canvas,
              antialias: true,
              alpha: true,
              powerPreference: "high-performance",
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(55, 1, 0.1, 100);
            camera.position.set(0, 0.15, 4.6);

            const amb = new THREE.AmbientLight(0xffffff, 0.55);
            scene.add(amb);

            const dir = new THREE.DirectionalLight(0xffffff, 0.75);
            dir.position.set(3, 4, 3);
            scene.add(dir);

            lightAccent = new THREE.PointLight(COLORS.accent, 0.6, 12, 2);
            lightAccent.position.set(0.5, 0.5, 2.2);
            scene.add(lightAccent);

            group = new THREE.Group();
            scene.add(group);

            const matCore = new THREE.MeshStandardMaterial({
              color: COLORS.surface,
              roughness: 0.25,
              metalness: 0.55,
              emissive: new THREE.Color(0x000000),
              emissiveIntensity: 1.0,
            });

            const matKnot = new THREE.MeshStandardMaterial({
              color: COLORS.muted,
              roughness: 0.35,
              metalness: 0.35,
              transparent: true,
              opacity: 0.55,
              emissive: new THREE.Color(0x000000),
              emissiveIntensity: 1.0,
            });

            knot = new THREE.Mesh(new THREE.TorusKnotGeometry(1.05, 0.18, 64, 8, 2, 3), matKnot);
            knot.rotation.x = Math.PI * 0.15;
            group.add(knot);

            core = new THREE.Mesh(new THREE.IcosahedronGeometry(0.55, 0), matCore);
            group.add(core);

            const satMat = new THREE.MeshStandardMaterial({
              color: COLORS.surface,
              roughness: 0.4,
              metalness: 0.2,
              transparent: true,
              opacity: 0.75,
              emissive: new THREE.Color(0x000000),
              emissiveIntensity: 1.0,
            });

            satellites = [];
            const satGeo = new THREE.SphereGeometry(0.09, 10, 10);
            for (let i = 0; i < 6; i++) {
              const m = new THREE.Mesh(satGeo, satMat.clone());
              satellites.push(m);
              group.add(m);
            }

            resize();

            // Keep the canvas sized to the arena (not the window)
            if (window.ResizeObserver) {
              const ro = new ResizeObserver(() => resize());
              ro.observe(arena);
            } else {
              window.addEventListener("resize", resize, { passive: true });
            }

            loop();
          };

          const resize = () => {
            if (!renderer || !camera) return;
            const { w, h } = getArenaSize();
            renderer.setSize(w, h, false);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
          };

          const setMode = (state) => {
            const reduced = prefersReducedMotion();

            if (state === STATES.WAITING) {
              anim.targetSpeed = reduced ? 0.10 : 0.14;
              anim.targetGlow = 0.25;
              anim.targetRed = 1.0;
              anim.targetJitter = 0.0;
            } else if (state === STATES.READY) {
              anim.targetSpeed = reduced ? 0.18 : 0.55;
              anim.targetGlow = 0.95;
              anim.targetRed = 0.0;
              anim.targetJitter = 0.0;
            } else if (state === STATES.TOO_EARLY) {
              anim.targetSpeed = reduced ? 0.2 : 0.42;
              anim.targetGlow = 0.35;
              anim.targetRed = 1.0;
              anim.targetJitter = 1.0;
            } else if (state === STATES.RESULT) {
              anim.targetSpeed = reduced ? 0.10 : 0.16;
              anim.targetGlow = 0.18;
              anim.targetRed = 0.0;
              anim.targetJitter = 0.0;
            } else {
              anim.targetSpeed = reduced ? 0.08 : 0.12;
              anim.targetGlow = 0.12;
              anim.targetRed = 0.0;
              anim.targetJitter = 0.0;
            }
          };

          const loop = () => {
            rafId = requestAnimationFrame(loop);
            if (!renderer || !scene || !camera || !group || !knot || !core) return;

            anim.speed = lerp(anim.speed, anim.targetSpeed, 0.06);
            anim.glow = lerp(anim.glow, anim.targetGlow, 0.08);
            anim.red = lerp(anim.red, anim.targetRed, 0.09);
            anim.jitter = lerp(anim.jitter, anim.targetJitter, 0.22);
            anim.targetJitter = lerp(anim.targetJitter, 0.0, 0.14);

            const t = performance.now() * 0.001;

            group.rotation.y += 0.0075 * anim.speed;
            group.rotation.x = Math.sin(t * 0.55) * 0.12;

            knot.rotation.z += 0.014 * anim.speed;
            core.rotation.y -= 0.02 * anim.speed;

            for (let i = 0; i < satellites.length; i++) {
              const a = t * (0.9 + i * 0.05) + i;
              const r = 1.55 + Math.sin(t * 0.7 + i) * 0.08;
              satellites[i].position.set(Math.cos(a) * r, Math.sin(a * 0.9) * 0.6, Math.sin(a) * 0.45);
              satellites[i].rotation.y += 0.02 * anim.speed;
            }

            const accent = new THREE.Color(COLORS.accent);
            const err = new THREE.Color(COLORS.error);
            const base = new THREE.Color(0x000000);
            const glowColor = base.clone().lerp(accent, anim.glow).lerp(err, anim.red * 0.9);

            knot.material.emissive.copy(glowColor);
            core.material.emissive.copy(glowColor.clone().lerp(accent, 0.3));

            for (let i = 0; i < satellites.length; i++) {
              satellites[i].material.emissive.copy(glowColor);
              satellites[i].material.opacity = 0.62 + anim.glow * 0.22;
            }

            if (lightAccent) {
              lightAccent.color.setHex(anim.red > 0.4 ? COLORS.error : COLORS.accent);
              lightAccent.intensity = 0.35 + anim.glow * 0.85;
            }

            if (anim.jitter > 0.001) {
              group.position.x = Math.sin(t * 60) * 0.03 * anim.jitter;
              group.position.y = Math.cos(t * 58) * 0.02 * anim.jitter;
            } else {
              group.position.x = 0;
              group.position.y = 0;
            }

            knot.material.opacity = 0.42 + anim.glow * 0.28;

            renderer.render(scene, camera);
          };

          return Object.freeze({ init, resize, setMode });
        })();

        const Game = (() => {
          let state = STATES.IDLE;
          let waitTimerId = 0;
          let readyAt = 0;

          const canInput = (s) =>
            s === STATES.IDLE || s === STATES.WAITING || s === STATES.READY || s === STATES.RESULT || s === STATES.TOO_EARLY;

          const clearWaitTimer = () => {
            if (waitTimerId) {
              clearTimeout(waitTimerId);
              waitTimerId = 0;
            }
          };

          const setState = (next, payload = {}) => {
            if (state === next) return;
            state = next;
            UI.renderStateView(state, payload);
            Visuals3D.setMode(state);
            UI.el.arenaButton.setAttribute("aria-label", `Game area. State ${state}. Press to interact.`);
          };

          const scheduleReady = () => {
            const delay = clampInt(1000 + Math.random() * 4000, 1000, 5000);
            clearWaitTimer();
            waitTimerId = setTimeout(() => {
              waitTimerId = 0;
              if (state !== STATES.WAITING) return;
              readyAt = now();
              setState(STATES.READY);
            }, delay);
          };

          const startRound = () => {
            if (state !== STATES.IDLE && state !== STATES.RESULT && state !== STATES.TOO_EARLY) return;
            readyAt = 0;
            setState(STATES.WAITING);
            scheduleReady();
          };

          const falseStart = () => {
            if (state !== STATES.WAITING) return;
            clearWaitTimer();
            readyAt = 0;
            setState(STATES.TOO_EARLY);
          };

          const stopOnReady = () => {
            if (state !== STATES.READY) return;

            const clickedAt = now();
            const reactionMs = clickedAt - readyAt;

            if (!Number.isFinite(reactionMs) || reactionMs <= 0 || reactionMs > 60000) {
              setState(STATES.IDLE);
              UI.announce("Invalid timing sample. Try again.");
              return;
            }

            Stats.addAttempt(reactionMs);

            const best = Storage.readBest();
            if (!Number.isFinite(best) || reactionMs < best) Storage.writeBest(reactionMs);

            const bestMs = Storage.readBest();
            const attempts = Stats.getAttempts();
            const avgMs = Stats.getAverage();
            const lastMs = Stats.getLast();

            UI.renderAttempts(attempts);
            UI.renderStats({
              currentMs: reactionMs,
              bestMs,
              avgMs,
              lastMs,
              sessionCount: Stats.getCount(),
            });

            setState(STATES.RESULT, { currentMs: reactionMs });
          };

          const onPrimaryInput = () => {
            if (!canInput(state)) return;

            if (state === STATES.IDLE || state === STATES.RESULT || state === STATES.TOO_EARLY) return startRound();
            if (state === STATES.WAITING) return falseStart();
            if (state === STATES.READY) return stopOnReady();
          };

          const resetSession = () => {
            Stats.resetSession();
            UI.renderAttempts(Stats.getAttempts());
            UI.renderStats({
              currentMs: NaN,
              bestMs: Storage.readBest(),
              avgMs: Stats.getAverage(),
              lastMs: Stats.getLast(),
              sessionCount: Stats.getCount(),
            });
            setState(STATES.IDLE);
            UI.announce("Session stats reset.");
          };

          const clearBest = () => {
            Storage.clearBest();
            UI.renderStats({
              currentMs: NaN,
              bestMs: Storage.readBest(),
              avgMs: Stats.getAverage(),
              lastMs: Stats.getLast(),
              sessionCount: Stats.getCount(),
            });
            UI.announce("Best time cleared.");
          };

          const init = () => {
            UI.renderAttempts(Stats.getAttempts());
            UI.renderStats({
              currentMs: NaN,
              bestMs: Storage.readBest(),
              avgMs: Stats.getAverage(),
              lastMs: Stats.getLast(),
              sessionCount: Stats.getCount(),
            });

            UI.renderStateView(STATES.IDLE);
            Visuals3D.setMode(STATES.IDLE);

            UI.el.arenaButton.addEventListener("click", (e) => {
              e.preventDefault();
              onPrimaryInput();
            });

            window.addEventListener(
              "keydown",
              (e) => {
                if (e.code === "Space" || e.code === "Enter") {
                  if (e.repeat) return;
                  e.preventDefault();
                  onPrimaryInput();
                }
              },
              { passive: false }
            );

            UI.el.btnResetSession.addEventListener("click", (e) => {
              e.preventDefault();
              resetSession();
            });

            UI.el.btnClearBest.addEventListener("click", (e) => {
              e.preventDefault();
              clearBest();
            });

            document.addEventListener("visibilitychange", () => {
              if (document.hidden) {
                clearWaitTimer();
                if (state === STATES.WAITING || state === STATES.READY) {
                  setState(STATES.IDLE);
                  UI.announce("Paused. Click to start again.");
                }
              }
            });
          };

          return Object.freeze({ init });
        })();

        const boot = () => {
          try {
            Visuals3D.init();
          } catch {}

          Game.init();
        };

        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", boot, { once: true });
        } else {
          boot();
        }
      })();
    </script>
  </body>
</html>